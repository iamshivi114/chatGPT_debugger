"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.FakeUserManager = void 0;
const signaling_1 = require("@lumino/signaling");
const services_1 = require("@jupyterlab/services");
/**
 * The user API service manager.
 */
class FakeUserManager extends services_1.BaseManager {
    /**
     * Create a new user manager.
     */
    constructor(options = {}, identity, permissions) {
        super(options);
        this._isReady = false;
        this._userChanged = new signaling_1.Signal(this);
        this._connectionFailure = new signaling_1.Signal(this);
        // Initialize internal data.
        this._ready = new Promise(resolve => {
            // Schedule updating the user to the next macro task queue.
            setTimeout(() => {
                this._identity = identity;
                this._permissions = permissions;
                this._userChanged.emit({
                    identity: this._identity,
                    permissions: this._permissions
                });
                resolve();
            }, 0);
        })
            .then(() => {
            if (this.isDisposed) {
                return;
            }
            this._isReady = true;
        })
            .catch(_ => undefined);
    }
    /**
     * Test whether the manager is ready.
     */
    get isReady() {
        return this._isReady;
    }
    /**
     * A promise that fulfills when the manager is ready.
     */
    get ready() {
        return this._ready;
    }
    /**
     * Get the most recently fetched identity.
     */
    get identity() {
        return this._identity;
    }
    /**
     * Get the most recently fetched permissions.
     */
    get permissions() {
        return this._permissions;
    }
    /**
     * A signal emitted when the user changes.
     */
    get userChanged() {
        return this._userChanged;
    }
    /**
     * A signal emitted when there is a connection failure.
     */
    get connectionFailure() {
        return this._connectionFailure;
    }
    /**
     * Dispose of the resources used by the manager.
     */
    dispose() {
        super.dispose();
    }
    /**
     * Force a refresh of the specs from the server.
     *
     * @returns A promise that resolves when the specs are fetched.
     *
     * #### Notes
     * This is intended to be called only in response to a user action,
     * since the manager maintains its internal state.
     */
    async refreshUser() {
        return Promise.resolve();
    }
}
exports.FakeUserManager = FakeUserManager;
//# sourceMappingURL=user.js.map